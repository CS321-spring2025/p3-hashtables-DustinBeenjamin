import java.io.File;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Random;
import java.util.Scanner;

/**
 * A class for running experiments on the insertion performance of
 * open addressed hashtables. Only linear and double hashing is supported.
 * Application enters at main, generates a LinearProbing and DoubleHashing 
 * hashtable, then fills them to a target load factor. Finally, it reports
 * either prints performance metrics, or saves them to a dump file, depending on 
 * the debug level selected. 
 * 
 * @author Benjamin Dustin
 */


/**
 * Provides non static methods and variables for the experiment
 */
public class HashtableExperiment {

    /**
     * Causes Random objects to utilize the seed
     */
    private boolean seedFlag = true; 
    
    /**
     * Seed value for Random objects
     */
    private int seed = 42;                 

    /**
     * Integer representation of the dataSource provided as an argument.
     * 1 -> Random integers
     * 2 -> 1 second sequential Date objects
     * 3 -> Words in the "word-list.txt" file
     */    
    private int dataSource;    
    
    /**
     * The target load factor of the hashtable for the current experiment
     */ 
    private float loadFactor;  
    
    /**
     * Integer representation of the loadFactor provided as an argument. Defaults to 0 in proccessArguments()
     */ 
    private int debugLevel;                 

    /**
     * The number of potential data sources
     */ 
    private int numDataSourceOptions = 3; 

    /**
     * THe number of potential debug options
     */ 
    private int numDebugOptions = 3;

    /**
     * The number of calls to the method getData()
     */ 
    private int getDataCalls = 0;

    /**
     * Data is stored here before being inserted into the hashtable
     */ 
    private ArrayList<Object> data;   
    
    /**
     * A random object. Stored globally to enable program to generate data in sections, instead of all at once
     */ 
    private Random random;

    /**
     * The first time generated by dataSource 2. Following times are sequential increments of 1000
     */ 
    private long currentTime = 0;

    /**
     * The path where the list of words is stored for dataSource 3
     */ 
    private String localPath = "word-list.txt";

    /**
     * The file used for for instantiating the Scanner used to read the list of words for dataSource 3.
     * Stored globally to enable program to generate data in sections, instead of all at once.
     */ 
    private File fileObj;

    /**
     * Scanner used for reading words in dataSource 3. Stored globally to enable program to generate data in sections, instead of all at once
     */ 
    private Scanner scanner;

    /**
     * A string for printing debug message. Describes the type of hashing done. Either "Linear" or "Double"
     */ 
    private String dataSourceString;

    /**
     * A method for validating command line arguments, and saving the information for future behavior if succesful
     * 
     * @param args A string array of the command line arguments passed to main()
     */
    private void processArguments(String[] args){
        
        //Verify the correct number of arguments
        switch (args.length) {
            case 0:
                printCorrectFormat();
                System.exit(0);
            case 3:
            case 2:
                break;
            default:
                close("Error: Two arguments are required, a third is optional. Closing the program.");
        }

        //Verify that first and optional third arguments are integer castable
        try {
            Integer.parseInt(args[0]);
            if (args.length == 3) {
                Integer.parseInt(args[2]);
            }
        } catch (Exception e) {
            close("Error: First and optional third argument must be integers. Closing program.");
        }


        //Verify second argument is float castable
        try {
            Float.parseFloat(args[1]);
        } catch (Exception e) {
            close("Error: Second argument must be float castable. Closing program");
        }

        //Assign data
        dataSource = Integer.parseInt(args[0]);
        loadFactor = Float.parseFloat(args[1]);
        debugLevel = (args.length == 3) ? Integer.parseInt(args[2]) : 0;


        //Verify that the data source integer is a valid option
        if (((dataSource / (numDataSourceOptions + 1)) != 0) || (dataSource < 1)) { close("Error: Data source " + dataSource + " is invalid."); }

        //Verify that the load factor is a valid option
        if ((loadFactor > 1) || (loadFactor <= 0)) { close("Error: Load factor must be positive and less than or equal to 1"); }

        //Verify that the debug level integer is a valid option
        if (((debugLevel / (numDebugOptions)) != 0) || (debugLevel < 0)) { close("Error: Debug level " + debugLevel + " is invalid.");}

        //Set the dataSourceString
        switch (dataSource) {
            case 1:
                dataSourceString = "Random-Integers";
                break;
            case 2:
                dataSourceString = "Date-Objects";
                break;
            case 3:
                dataSourceString = "Word-List";
                break;
        }
        
    }

    /**
     * Fills data<Object> with data from the source selected upon program execution. If data<Object> already has data, then it doubles data<Objects>'s
     * size and data.
     * 
     * @param tableLength The number of elements the hashtable can hold
     */
    private void getData(int tableLength) {
        int numElementsToAdd;
        getDataCalls++;

        if (data == null) {
            data =  new ArrayList<Object>(tableLength);
            numElementsToAdd = tableLength;
        } else {
            //Calculate the number of elements to add to data to double its size
            numElementsToAdd = (int) Math.pow(2, getDataCalls - 2) * tableLength;
        }


        switch (dataSource) {
            case 1:
                generateRandomInts(numElementsToAdd);
                break;
            case 2:
                generateRandomFloats(numElementsToAdd);
                break;
            case 3: 
                generateStrings(numElementsToAdd);
                break;
        }
    }

    /**
     * Fills data<object> with enough random integers to double its size
     * 
     * @param numElementsToAdd The number of elements to add in order to double data<Object>'s size.
     */
    private void generateRandomInts(int numElementsToAdd){
        //Verify that the global Random object is not null
        if (random == null) { random = (seedFlag) ? new Random(seed) : new Random(); }

        //Generate random ints and add them to data
        for (int i = 0; i < numElementsToAdd; i++) {
            data.add(random.nextInt());
        }
    }

    /**
     * Fills data<object> with enough sequenctial Data objects in order to double its size
     * 
     * @param numElementsToAdd The number of elements to add in order to double data<Object>'s size.
     */
    private void generateRandomFloats(int numElementsToAdd){
        //Get an original base time
        if (currentTime == 0) { currentTime = new Date().getTime(); }

        //create 1 second sequential Data objects and add them to data
        for (int i = 0; i < numElementsToAdd; i++) {
            data.add(new Date(currentTime));
            currentTime += 1000;
        }
    }

    /**
     * Fills data<object> with enough String objects in order to double its size. Sources Strings for "word-list.txt"
     * 
     * @param numElementsToAdd The number of elements to add in order to double data<Object>'s size.
     */
    private void generateStrings(int numElementsToAdd){
        //Create scanner object for "word-list.txt"
        if (fileObj == null) {
            fileObj = new File(localPath);
            try {
                scanner = new Scanner(fileObj);
            } catch (Exception e) {
                close("Scanner unable to open " + localPath);
            }
        }
        
        //Insert each line of "word-list.txt" as a data entry of data<Object>
        for (int i = 0; i < numElementsToAdd; i++) {
            if (scanner.hasNext()) {
                data.add(scanner.nextLine().strip());
            }
        }
}

    /**
     * Fills a hashtable object with data from Data<Object>
     * 
     * @param table The hashtable object where data should be inserted.
     * @param tableLength The number of elements that the hashtable can hold
     * @param startIndex The index of Data<Object> where data should be inserted from initially
     * @return The number of times an insertion was attempted on the table (includes inserting duplicate data)
     */
    private int insertData(Hashtable table, int tableLength, int startIndex){
        //Calculate number of elements hashtable should have to achiieve desired loadFactor
        int targetNumElements = (int) Math.ceil(loadFactor * tableLength);

        //The index where data should pulled from Data<Object>
        int i = startIndex;

        //Verify that data<Object> is not empty
        if (data == null) {
            getData(tableLength);
        }

        //"While the hashtable doesnt have enough arguments, and data<Object> has data that has not been inserted"
        while ((table.getSize() < targetNumElements) && (i < data.size())) {
            int startSize = table.getSize();

            //Try to insert 
            boolean insertionStatus = table.insert(data.get(i));

            //Format debug level 2 - printing wether or not insertion was succesful and if it was a duplcate or original
            if (debugLevel == 2) {
                String insertionMessage = insertionStatus ? "succesfully" : "unsuccesfully";
                String duplicateInsertionMessage = table.getSize() > startSize ? "new data" : "duplicate";
                String messageTail = insertionStatus ? " " + insertionMessage + " as " + duplicateInsertionMessage : insertionMessage;
                System.out.println(table.getHashingType() + ":\tInserted " + data.get(i) + messageTail);
            }
            i++;
        }

        //"If the table needs more elements to achieve target load factor, generate more data and insert it recursively"
        if (table.getSize() < targetNumElements) {
            getData(tableLength);
            return insertData(table, tableLength, i);
        }

        //return the number of attempts to insert
        return i;
    }

    /**
     * Prints the debug message appropriate to the debug level provided to main in args[]
     * 
     * @param tableLength The number of elements that the hashtable can hold
     * @param linearTable The LinearProbing object of the experiment
     * @param DoubleTable The DoubleHashing object of the experiment
     * @param linearInsertions The number of times that insertions were attempted on linearTable
     * @param doubleInsertions The number of times that insertions were attempted on doubleTable
     */
    private void printDebugMessage(int tableLength, LinearProbing linearTable, DoubleHashing doubleTable, int linearInsertions, int doubleInsertions){
        DecimalFormat formatter = new DecimalFormat("#0.00");
        System.out.println("HashtableExperiment: Found a twin prime table capacity: " + tableLength);
        System.out.println("HashtableExperiment: Input: " + dataSourceString +" Loadfactor: " + formatter.format(loadFactor) + "\n");

        switch (debugLevel) {
            case 0:
                System.out.println(linearTable.probeSummary(linearInsertions));
                System.out.println(doubleTable.probeSummary(doubleInsertions));
                break;
            case 1:
                System.out.println(linearTable.probeSummary(linearInsertions) + "HashtableExperiment: Saved dump of hash table to linear-dump.txt\n");
                System.out.println(doubleTable.probeSummary(doubleInsertions) + "HashtableExperiment: Saved dump of hash table to double-dump.txt\n");
                linearTable.dumpToFile("linear-dump.txt");
                doubleTable.dumpToFile("double-dump.txt");

                break;
            case 2:
                //DO NOTHING, THIS IS HANDLED IN insertData.
                break;
        
        }
    }

    /**
     * Constructor for HashtableExperiment. Necesary for accessing non static methods.
     */
    public void HashtableExperiment(){
        //Do nothing
    }




    
    public static void main(String[] args) {


        //Instatiate HashtableExperiment for access to non static methods
        HashtableExperiment experiment = new HashtableExperiment(); 

        int tableLength = TwinPrimeGenerator.generateTwinPrime(95500, 96000);       
        
        LinearProbing linearTable = new LinearProbing(tableLength);                     
        DoubleHashing doubleTable = new DoubleHashing(tableLength);
        
        // String[] tempArgs = {"3", "0.5"};
        // experiment.processArguments(tempArgs);
        experiment.processArguments(args);

        int doubleInsertions = experiment.insertData(doubleTable, tableLength, 0);
        int linearInsertions = experiment.insertData(linearTable, tableLength, 0);

        experiment.printDebugMessage(tableLength, linearTable, doubleTable, linearInsertions, doubleInsertions);

    }


    /**
     * Static method for printing the correct command line usage and arguments options
     */
    private static void printCorrectFormat(){
        System.out.println("Usage: java HashtableExperiment <dataSource> <loadFactor> [<debugLevel>]");
        System.out.println("       <dataSource>: 1 ==> random numbers");
        System.out.println("                     2 ==> date value as a long");
        System.out.println("                     3 ==> word list");

        System.out.println("       <loadFactor>: The ratio of objects to table size, denoted by alpha = n/m");

        System.out.println("       <debugLevel>: 0 ==> print summary of experiment");
        System.out.println("                     1 ==> save the two hash tables to a file at the end");
        System.out.println("                     2 ==> print debugging output for each insert");
    }
    
    /**
     * A static method used for printing an Error message to terminal, and closing the application.
     * @param message The error message that should be printed to the terminal before closing application.
     */
    private static void close(String message) {
        System.out.println(message);
        printCorrectFormat();
        System.exit(0);
    }
}